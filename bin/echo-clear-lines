#!/usr/bin/env bash
source "$DOTFILES/sources/strict.bash"

function help {
	cat <<-EOF >/dev/stderr
		ABOUT:
		Deletes as many lines as it received.

		USAGE:
		echo $'one\ntwo\nthree'; echo-clear-lines $'two\nthree'
		# ^ outputs: one

		echo 'sup'; printf 'a\nb\nc' | echo-clear-lines --piped
		# ^ outputs: sup

		header="\$(mktemp)"; echo 'sup'; printf 'a\nb\nc' | tee "\$header"; echo-clear-lines < "\$header"
		# ^ outputs: sup
	EOF
}

# test cases:
# confirm --ppid=$$ -- "Press any key to continue..."
# ^ without \e[J it will have an indentation at the start

piped='no'
if test "${1-}" = '--piped'; then
	piped='yes'
	shift
fi

function arg {
	echo-clear-lines <<<"$*"
	exit "$?"
}
function line {
	if test "$piped" = 'yes'; then
		# erase current line
		printf $'\e[2K\e[G'
	else
		# delete prior line (aka echo-clear-line)
		printf $'\e[F\e[J'
	fi
}
function inline {
	# erase current line
	printf $'\e[2K\e[G'
}

source "$DOTFILES/sources/stdinargs.bash"

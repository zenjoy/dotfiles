#!/usr/bin/env bash
source "$DOTFILES/sources/strict.bash"
source "$DOTFILES/sources/arrays.bash"
requires_array_support 'mapfile'

# dependencies
export QUIET=yes
source "$DOTFILES/sources/ripgrep.bash"
source "$(which setup-util-gsed)"
setup-util-sd
export QUIET=no

# test
if is-needle '--test' "$@"; then
	(
		# prepare
		echo-segment --h1="TEST: $0"
		echo
		file="$(mktemp)"
		missing_file="$(fs-temp)"

		# test invalid arguments fail
		eval-tester --ec=22 -- config-helper
		eval-tester --ec=22 -- config-helper --file="$missing_file"
		eval-tester --ec=22 -- config-helper "$missing_file"

		# test an non-existent file
		eval-tester -- config-helper --file="$missing_file" -- \
			--find='commands.local[/]' --replace='commands.local/' \
			--find='config.local[/]' --replace='config.local/'
		eval-tester --stdout=$'commands.local/\nconfig.local/' -- cat "$missing_file"

		# test invalid find and replace arguments
		eval-tester --ec=22 -- config-helper --file="$file" -- --replace='one'
		eval-tester --ec=22 -- config-helper --file="$file" -- --find='a' --replace='one' --replace='two'
		# ^ first find and replace succeeds, hence "one", second find and replace failed, hence no two
		eval-tester --stdout='one' -- cat "$file"

		# test an empty file
		eval-tester -- config-helper --file="$file" -- \
			--find='commands.local[/]' --replace='commands.local/' \
			--find='config.local[/]' --replace='config.local/'
		eval-tester --stdout=$'one\ncommands.local/\nconfig.local/' -- cat "$file"

		# test a file that as results
		eval-tester -- config-helper --file="$file" -- \
			--find='commands.local[/]' --replace='commands.replaced/' \
			--find='config.local[/]' --replace='config.replaced/'
		eval-tester --stdout=$'one\ncommands.replaced/\nconfig.replaced/' -- cat "$file"

		# test find only, used by <sharebox> command
		echo $'User=uu\n\tGroup=gg\n\t# Party=pp' >"$file"
		eval-tester --stdout=$'User=uu\nuu\nGroup=gg\ngg' -- config-helper --file="$file" -- \
			--find='User=(.*)' \
			--field='User' \
			--find='Group=(.*)' \
			--field='Group' \
			--find='Party=(.*)' \
			--field='Party'

		# uncomment party
		eval-tester --stdout='sup' -- config-helper --quiet --file="$file" -- \
			--find='Party=(.*)' --replace='Party=sup' \
			--field='Party'

		# test variable replacements and additions
		echo $'a=one\n\tb=(two three)\n\ta=three\n\tb=(four five)' >"$file"
		eval-tester -- config-helper --quiet --file="$file" -- \
			--field='a' --no-quote --value='1' \
			--field='b' --array="$(echo-lines -- 2 3)" \
			--field='aa' --value='value replacement' \
			--field='bb' --array="$(echo-lines -- 22 33)"
		eval-tester --stdout=$'a=1\n\tb=(\n\t\t\'2\'\n\t\t\'3\'\n\t)\naa=\'value replacement\'\nbb=(\n\t\'22\'\n\t\'33\'\n)' -- cat "$file"

		# test complicated valyes
		echo $'a=one\n\tb=(two three)\n\ta=three\n\tb=(four five)' >"$file"
		eval-tester -- config-helper --quiet --file="$file" -- \
			--field='a' --value='double "quote" inside' \
			--field='b' --columns=2 --array="$(echo-lines -- 'double "quote" inside' "single 'quote' inside" 3 4)" \
			--field='aa' --value="single 'quote' inside" \
			--field='bb' --columns=2 --array="$(echo-lines -- 'more double "quote" inside' "more single 'quote' inside" 33 44)"
		eval-tester --stdout=$'a=\'double "quote" inside\'\n\tb=(\n\t\t\'double "quote" inside\'\t"single \'quote\' inside"\n\t\t\'3\'\t\'4\'\n\t)\naa="single \'quote\' inside"\nbb=(\n\t\'more double "quote" inside\'\t"more single \'quote\' inside"\n\t\'33\'\t\'44\'\n)' -- cat "$file"

		# done
		echo-segment --g1="TEST: $0"
	)
	exit "$?"
fi

# =====================================
# Arguments

# help
function help() {
	cat <<-EOF >/dev/stderr
		USAGE:
		config-helper <file> -- ...
			[--find=<pattern>] # outputs the found result
			[--find=<pattern> [--replace=<pattern>]] # replaces the pattern with the pattern
			[--field=<field>] # outputs the value of the field
			[--field=<field> [--value=<value>]] # sets the field to the value
			[--field=<field> [--array=<lines>]] # sets the field to an array of the lines

		QUIRKS:
		If a commented --find=<pattern> or --field=<field> is found, the replacement will be placed there.
		If multiple results are found, the replacement will only leave the replacement.
	EOF
	if test "$#" -ne 0; then
		echo-style $'\n' --error="ERROR:" $'\n' --red="$(echo-lines -- "$@")" >/dev/stderr
	fi
	return 22 # Invalid argument
}

# e.g.
# /etc/systemd/resolved.conf
# shell.sh
# .gitignore
file=''

# process
args=()
quiet='no'
while test "$#" -ne 0; do
	item="$1"
	shift
	case "$item" in
	'help' | '--help' | '-h') help ;;
	'--file='*) file="${item:7}" ;;
	'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*)
		quiet="$(is-quiet --missing="$quiet" -- "$item")"
		;;
	'--')
		args+=("$@")
		shift $#
		break
		;;
	'--'*) help "An unrecognised flag was provided: $item" ;;
	*)
		if test -z "$file"; then
			file="$item"
		else
			help "An unrecognised argument was provided: $item"
		fi
		;;
	esac
done

# check
if test "${#args[@]}" -eq 0; then
	help "Need arguments, otherwise what is the point?"
fi

# ensure file
if test -z "$file"; then
	help "Need a file to work with"
fi

# ensure file exists
if test ! -f "$file"; then
	touch "$file"
fi

# =====================================
# Action

# prepare
updated='no'

# cycle
function act() {
	local option_search option_columns='1' option_quote='yes' option_replace search_pattern replace_pattern get_value_pattern sed_excess_pattern excess_value addition find field value
	while test "$#" -ne 0; do
		# extract arguments
		option_search="$1"
		shift

		# extract special cases
		case "${1-}" in
		'--columns='*)
			option_columns="${1:10}"
			shift
			;;
		'--no-quote')
			option_quote='no'
			shift
			;;
		esac

		# extract next argument, shift is handled later, as could ba another find
		option_replace="${1-}"

		# reset variables
		search_pattern=''
		replace_pattern=''
		get_value_pattern=''
		sed_excess_pattern=''
		excess_value=''
		addition=''
		find=''  # value of --find=<value>
		field='' # value of --field=<value>
		value='' # value of --{replace,array,value}=<value>

		# search
		# https://docs.rs/regex/latest/regex/
		# (?flags:exp)   set flags for exp (non-capturing)
		# m     multi-line mode: ^ and $ match begin/end of line
		# u     Unicode support (enabled by default)
		# x     ignore whitespace and allow line comments (starting with `#`)
		# ^ x doesn't seem to work
		# sed magic is from https://unix.stackexchange.com/a/569675/50703
		# the (?m) prefix turns out not be necessary, for sed, nor ripgrep
		if [[ "$option_search" = '--pattern='* ]]; then
			# raw pattern
			search_pattern="(?P<value>${option_search:10})" # undocumented
			get_value_pattern="$search_pattern"
		elif [[ "$option_search" = '--find='* ]]; then
			# indentable, commentable, pattern
			find="${option_search:7}"
			search_pattern="^(?P<indent>[[:blank:]]*)(?P<comment>(?:#|[[:blank:]])*)(?P<value>${find})$"
			get_value_pattern="^(?P<indent>[[:blank:]]*)(?P<value>${find})$" # ignore comments
			sed_excess_pattern="0,/[# 	]*${find}/!{//d}"
			excess_value="\${indent}${field}=$RANDOM"
		elif [[ "$option_search" = '--field='* ]]; then
			# field that can be an array and value
			field="${option_search:8}"
			search_pattern="^(?P<indent>[[:blank:]]*)(?P<comment>(?:#|[[:blank:]])*)${field} *= *(?P<value>[(](?ms:.*?)[)]|[^\n]*)$"
			get_value_pattern="^(?P<indent>[[:blank:]]*)${field} *= *(?P<value>[(](?ms:.*?)[)]|[^\n]*)$" # ignore comments
			sed_excess_pattern="0,/[# 	]*${field} *= *(.*?)/!{//d}"
			excess_value="\${indent}${field}=$RANDOM"
		else
			help "Invalid search argument [$option_search] it must be either --find=<pattern> or --field=<field>"
		fi

		# addition/replace
		if [[ "$option_replace" = '--replace='* ]]; then
			# replace value
			value="${option_replace:10}"
			addition="$value"
			replace_pattern="$value"
		elif [[ "$option_replace" = '--array='* ]]; then
			value="${option_replace:8}"

			# check for field
			if test -z "$field"; then
				help "--array=<$value> must be used with --field=<field>"
			fi

			# adapt for array
			mapfile -t lines <<<"$value" # read lines into an array, such that indentation works
			# echo-verbose "${lines[@]}" >/dev/tty

			# addition
			value=$'(\n'"$(echo-lines --indent=$'\t' --quoted --columns="${option_columns:-"1"}" -- "${lines[@]}")"$'\n)'
			addition="${field}=${value}"

			# replacement
			value=$'(\n'"$(echo-lines --indent=$'${indent}\t' --quoted --columns="${option_columns:-"1"}" -- "${lines[@]}")"$'\n${indent})'
			replace_pattern="\${indent}${field}=${value}"

			# reset columns
			option_columns='1'
		elif [[ "$option_replace" = '--value='* ]]; then
			value="${option_replace:8}"

			# check for field
			if test -z "$field"; then
				help "--value=<$value> must be used with --field=<field>"
			fi

			# addition and replacement
			if test "$option_quote" = 'yes'; then
				value="$(echo-quote "$value")"
			fi
			addition="${field}=${value}"
			replace_pattern="\${indent}${field}=${value}"
			option_quote='yes'
		else
			# the replacement field was a find value, do not shift it, as we will use it in the next cycle
			# instead, fetch the value, then continue to use the field as the next find
			# --max-count=1 is to workaround: https://github.com/BurntSushi/ripgrep/issues/2095
			rg --max-count=1 --multiline --only-matching "$get_value_pattern" --replace '${value}' "$file" || :
			continue
		fi

		# replacement field is a replacement field, and not another find
		# as such, trim it from the next cycle, as we are using it now
		shift

		# and perform the replace
		if rg --quiet --multiline "$search_pattern" "$file"; then
			# trim all but the first occurance, this is complicated because these aren't a thing:
			# https://github.com/BurntSushi/ripgrep/issues/2094
			# https://github.com/chmln/sd/issues/105
			# https://github.com/greymd/teip/issues/27
			if test -n "$sed_excess_pattern"; then
				if test -n "$field"; then
					# make everything a single line, as gsed can't do multiple lines
					sd "$search_pattern" "$excess_value" "$file"
				fi
				# trim everything but the first occurance
				gsed -i -E "$sed_excess_pattern" "$file"
			fi

			# it was found, use sd for the replacement
			sd "$search_pattern" "$replace_pattern" "$file"
		else
			# it wasn't found, so add manually if it's not empty
			if test -n "$addition"; then
				echo "$addition" >>"$file"
			fi
		fi

		# a valid update occured, note for logging
		updated='yes'
	done
}

# act
act "${args[@]}"

# we do our own processing, as we need to support multiline matches
if test "$updated" = 'yes' -a "$quiet" = 'no'; then
	echo-style --success="Updated configuration file: $file" >/dev/tty
fi

#!/usr/bin/env bash
source "$DOTFILES/sources/strict.bash"
source "$DOTFILES/sources/tty.bash"

# NOTES:
# - [--default] and [--required] do not make sense here, as those are for high-level handling, this is just menu navigation

# QUIRKS:
# - if there are more options than [$LINES - header], then this will fall apart

# TODOS:
# - [ ] adopt modern arg and help and invalid arg handling
# - [ ] limit the options output to [$LINES - header]
# - [ ] if one gets to $LINES, and there are truncated values, then "scroll" downwards
# - [ ] support $COLUMNS - if a menu item is larger than the column, then it will show all of it when active

# validate
if is-help-separator "$@"; then
	cat <<-EOF >/dev/stderr
		ABOUT:
		Display a menu that the user can navigate using the keyboard.

		USAGE:
		choose-menu [...flags] -- <...items>

		RETURNS:
		the index of the result

		FLAGS:
		Provide [--question=...] to specify the question that the prompt will be answering.
		Provide [--multi] to specify that multiple menu items should be able to be selected.
		Provide [--timeout=...] to specify a custom timeout value in seconds.
	EOF
	exit 22 # Invalid argument
fi

# now that we have ensured separator exists, we don't need empty, only mapfile
source "$DOTFILES/sources/arrays.bash"
requires_array_support 'mapfile'

# fetch options in a way that works with multi-line values
options=()
while [ $# -gt 0 ]; do
	if [ "$1" = '--' ]; then
		shift
		break
	fi
	options+=("$1")
	shift
done
option_question="$(get-flag-value question -- "${options[@]}")"
option_timeout="$(get-flag-value timeout -- "${options[@]}")"
option_multi="$(get-flag-value multi --missing=no -- "${options[@]}" | echo-affirmative)"
option_required="$(get-flag-value required --missing=no -- "${options[@]}" | echo-affirmative)"

# prepare choices
choices=("$@")

# ensure we have items
if test "${#choices[@]}" -eq 0; then
	{
		echo-style --error="No items were provided. See [$0 --help] for usage."
		sleep 5
		exit 22 # Invalid argument
	} >/dev/stderr
elif is-array-partial "${choices[@]}"; then
	{
		echo-style --error="Empty items were provided. See [$0 --help] for usage."
		echo-verbose "${choices[@]}"
		sleep 5
		exit 22 # Invalid argument
	} >/dev/stderr
fi

# prepare
cursor=0
count="${#choices[@]}"
last="$((count - 1))"
action=''
mapfile -t selections < <(get-array "$count")

function print-menu() {
  # question
	if test -n "$option_question"; then
		echo "$option_question"
	fi

  # show the menu
	for i in "${!choices[@]}"; do
		if test "$i" -eq "$cursor"; then
			echo -n ">"
		else
			echo -n ' '
		fi
		if test "${selections[$i]-}" = 'yes'; then
			echo -n "*"
		else
			echo -n ' '
		fi
		choice="${choices[$i]}"
		echo "$choice"
	done
}

# commence
while test "$action" != 'done'; do
	
	# show the menu
	MENU=$(print-menu)
  echo "$MENU" >/dev/tty

	# handle the response
	ec=0 && action="$(read-arrow --timeout="$option_timeout")" || ec="$?"

	# check
	if test "$ec" -eq 62; then
		echo "Input timed out [$ec]." >/dev/stderr
		sleep 5
		exit "$ec"
	elif test "$ec" -ne 0; then
		echo "Input failed [$ec]." >/dev/stderr
		# some other failure
		sleep 5
		exit "$ec"
	fi

	# handle special cases and remaps
	# such as numbers, wasd, and vim movers
	if is-digit "$action"; then
		# number jump
		if test "$action" -le 1; then
			cursor=0
		elif test "$action" -le "$count"; then
			cursor="$((action - 1))"
		else
			cursor="$last"
		fi
		action='space'
	elif test "$action" = "left" -o "$action" = "h" -o "$action" = "k" -o "$action" = "a" -o "$action" = "w"; then
		action='up'
	elif test "$action" = "right" -o "$action" = "l" -o "$action" = "j" -o "$action" = "d" -o "$action" = "s"; then
		action='down'
	fi

	# control key
	if test "$action" = "up"; then
		if test "$cursor" -ne 0; then
			cursor="$((cursor - 1))"
		fi
	elif test "$action" = "down"; then
		if test "$cursor" -ne "$last"; then
			cursor="$((cursor + 1))"
		fi
	elif test "$action" = "home"; then
		cursor=0
	elif test "$action" = "end"; then
		cursor="$last"
	elif test "$action" = "backspace"; then
		# unselect everything
		for i in "${!choices[@]}"; do
			selections[$i]=''
		done
	elif test "$action" = "all" -a "$option_multi" = 'yes'; then
		# select everything
		for i in "${!choices[@]}"; do
			selections[$i]='yes'
		done
	elif test "$action" = 'tab'; then
		# select and move to next line
		selections[$cursor]='yes'
		if test "$cursor" -eq "$last"; then
			cursor=0
		elif test "$cursor" -lt "$last"; then
			cursor="$((cursor + 1))"
		fi
	elif test "$action" = 'space'; then
		# toggle single
		if test "${selections[$cursor]}" = 'yes'; then
			selections[$cursor]=''
		else
			selections[$cursor]='yes'
			if test "$option_multi" != 'yes'; then
				break
			fi
		fi
	elif test "$action" = "enter"; then
		if test "$option_multi" != 'yes'; then
			selections[$cursor]='yes'
		fi
		break
	elif test "$action" = "escape"; then
		# todo implement --required with --multi fallback properly here
		if test "$option_required" = 'no'; then
			break
		fi
	fi

	# no break, so repeat the menu
  echo-clear-lines "$MENU" >/dev/tty
done

# if multi with no selection then ask for everything
# todo implement --required properly here
if is-array-empty "${selections[@]}" && test "$option_multi" = 'yes'; then
	if confirm-positive --ppid=$$ -- "You exited without selecting anything, do you wish to select all?" >/dev/tty; then
		for i in "${!choices[@]}"; do
			selections[$i]='yes'
		done
	fi
fi

# output the custom selections
for i in "${!selections[@]}"; do
	selection="${selections[$i]}"
	if test "$selection" = 'yes'; then
		echo "$i"
	fi
done

#!/usr/bin/env bash
# shellcheck disable=SC2059
# ^ [echo -en] doesn't work with escape codes on bash v3, [printf ...] does
source "$DOTFILES/sources/strict.bash"

# =====================================
# Arguments

# help
function help() {
	cat <<-EOF >/dev/stderr
		USAGE:
		confirm --ppid=\$\$ [<...flags>] -- [<question> [<...details>]]

		FLAGS:
		[--mode=<bool, positive, negative, confirm>]
		[--timeout=<timeout in seconds>]
		[--yes=<on positive confirmations, what value to display>]
		[--no=<on negative confirmations, what value to display>]
		[--abort=<on aborted confirmations, what value to display>]
		[--ppid=<on aborted confirmations, terminate this process id>]

		QUIRKS:
		Why is --ppid=\$\$ necessary?
		As negative confirmations return a failure exit code, and abortions a different failure exit code, you probably need to use [--ppid=\$\$] so that confirmation abortions actually continue the abortion, and are not just considered a negative confirmation.
	EOF
	if test "$#" -ne 0; then
		echo-style $'\n' --error="ERROR:" $'\n' --red="$(echo-lines -- "$@")" >/dev/stderr
	fi
	return 22 # Invalid argument
}

# process
option_mode='confirm'
option_timeout='3600' # one hour
option_yes='OK'
option_no='CANCEL'
option_abort='ABORT'
option_ppid=''
question_parts=()
while test "$#" -ne 0; do
	item="$1"
	shift
	case "$item" in
	'help' | '--help' | '-h') help ;;
	'--mode='*)
		option_mode="${item:7}" # bool/positive/negative/confirm
		if test "$option_mode" = 'positive' -o "$option_mode" = 'negative'; then
			option_timeout='60' # one minute
			option_yes='YES'
			option_no='NO'
		elif test "$option_mode" = 'bool'; then
			option_yes='YES'
			option_no='NO'
		fi
		;;
	'--timeout='*) option_timeout="${item:10}" ;;
	'--yes='*) option_yes="${item:6}" ;;
	'--no='*) option_no="${item:5}" ;;
	'--abort='*) option_abort="${item:8}" ;;
	'--ppid='*) option_ppid="${item:7}" ;; # alias for term
	'--')
		question_parts+=("$@")
		shift $#
		break
		;;
	'--'*) help "An unrecognised flag was provided: $item" ;;
	*) help "An unrecognised argument was provided: $item" ;;
	esac
done

# requirements
if test -z "$option_ppid"; then
	help '--ppid=$$ is necessary'
fi

# =====================================
# Helpers

# used to process the input
function confirmer() {
	local ec answer

	# ask and timeout
	ec=0 && answer="$(read-arrow --timeout "$option_timeout")" || ec="$?"

	# process
	if test "$option_mode" = 'positive'; then
		# positive
		if test "$ec" -eq 62; then
			return 0 # timeout
		elif test "$ec" -ne 0; then
			return "$ec" # failure
		fi
		ec=0 && is-affirmative "$answer" || ec="$?"
		if test "$ec" -lt 2; then
			return "$ec"
		elif test "$answer" = 'enter' -o "$answer" = 'space'; then
			return 0
		elif test "$answer" = 'escape' -o "$answer" = 'q'; then
			return 125 # Operation canceled
		fi

	elif test "$option_mode" = 'negative'; then
		# negative
		if test "$ec" -eq 62; then
			return 1 # timeout
		elif test "$ec" -ne 0; then
			return "$ec" # failure
		fi
		ec=0 && is-affirmative "$answer" || ec="$?"
		if test "$ec" -lt 2; then
			return "$ec"
		elif test "$answer" = 'enter' -o "$answer" = 'space'; then
			return 1
		elif test "$answer" = 'escape' -o "$answer" = 'q'; then
			return 125 # Operation canceled
		fi

	elif test "$option_mode" = 'bool'; then
		# bool
		if test "$ec" -ne 0; then
			return "$ec" # timeout and failure
		fi
		ec=0 && is-affirmative "$answer" || ec="$?"
		if test "$ec" -lt 2; then
			return "$ec"
		elif test "$answer" = 'escape' -o "$answer" = 'q'; then
			return 125 # Operation canceled
		fi

	else
		# confirm
		if test "$ec" -ne 0; then
			return "$ec" # timeout and failure
		fi
		if test "$answer" = 'escape'; then
			return 125 # Operation canceled
		else
			# @todo what happens here if scrolling on ssh
			return 0
		fi
	fi

	# try again, and erase any leaked characters
	printf "\e[${hx}G\e[K"
	confirmer "$@"
	return "$?" # return with the above on success and failure
}

# =====================================
# Question

# prepare
question_first_part="${question_parts[0]} " # this is stored for the finale
question_parts_total="${#question_parts[@]}"
question_parts_last="$((question_parts_total - 1))"
header="$(mktemp)"
lines=0
ec=0

# update the first question part
if test "$option_mode" = 'positive'; then
	question_parts[0]+=" $(echo-style --blink='(' --blink+green+bold='Y' --blink='/n)')"
elif test "$option_mode" = 'negative'; then
	question_parts[0]+=" $(echo-style --blink='(y/' --blink+red+bold='N' --blink=')')"
elif test "$option_mode" = 'bool'; then
	question_parts[0]+=" $(echo-style --blink='(y/n)')"
fi

# output the question parts
# saving the cursor position of the first line
# and outputting a newline beteen all lines, except the last, which should not have a trailing line
for ((i = 0; i < "$question_parts_total"; i++)); do
	echo -n "${question_parts[i]} " | tee -a "$header"
	if test "$i" -eq 0; then
		# read cursor x y, discard y, set hx to y
		IFS='[;' read -srd R -p $'\e[6n' _ _ hx
	fi
	if test "$i" -ne "$question_parts_last"; then
		echo | tee -a "$header"
	fi
done

# move the cursor
if test "$question_parts_total" -ne 0; then
	# reposition the cursor, to after the options in the first part
	lines="$(echo-count-lines --no-inline <"$header")"
	# move these lines up
	if test "$lines" -ne 0; then
		printf "\e[${lines}F"
	fi
	# move to the hx column
	printf "\e[${hx}G"
fi

# handle terminations
function failure() {
	ec="$?"
}
function finish() {
	# in case we were called naturally, erase the listen
	trap - EXIT
	# make sure to erase question, as ctrl+c buggers everything
	echo -n $'\e[G\e[J'
	# output the finale
	if test "$ec" -eq 0; then
		echo-style "$question_first_part" --green+bold="$option_yes"
	elif test "$ec" -eq 1; then
		echo-style "$question_first_part" --red+bold="$option_no"
	else
		echo-style "$question_first_part" --red+bold="$option_abort"
		if test -n "$option_ppid"; then
			# kill "-$ec" ...
			# ^ fails because 130 isn't supported
			# kill -n ... ...
			# kill "-$(kill -l "$ec")" ...
			# ^ works but isn't serious enough to cause the termination
			# "$(ps -p $$ -o ppid=)"
			# ^ doesn't work, as is different pid than manual
			kill "$option_ppid"
		fi
	fi
}
trap failure SIGINT SIGTERM
trap finish EXIT

# read and handle answer
confirmer || ec="$?"
finish
exit "$ec" # exit with the result

# @todo
# an alternative implementation could be a new line like this at the end, with ENTER and ESCAPE and SPACE as the correct outputs
# echo-style --blink='Press: ' --blink+green+bold='y ' --blink='for ' --blink+green='YES' --blink=', ' --blink+red+bold='n ' --blink='for ' --blink+red='NO' --blink=', ' --blink+bold='ENTER '  --blink='for ' --blink+red='NO'

# using \e[s (save) and \e[u (restore) for ctrl+c handling did not work

#!/usr/bin/env bash
source "$DOTFILES/sources/strict.bash"

if is-help-separator "$@"; then
	cat <<-EOF >/dev/stderr
		USAGE:
		get-flag-value <flag> [--multi] [--yes=...] [--no=...] [--missing=...] -- <--flag=value> <--flag> <--no-flag> ...

		FLAGS:
		Provide [--multi] to output the value for each occurence of the flag, instead of just the first.
		Provide [--yes=...] to customise the value for when the flag is provided without any value.
		Provide [--missing=...] to customise the value for when the flag is missing.

		QUIRKS:
		It does not support [--flag value], only [--[no-]flag=[value]].

		EXAMPLES:

		get-flag-value var --
		^ outputs nothing

		get-flag-value var -- --var
		^ outputs: yes

		get-flag-value var -- --no-var
		^ outputs: no

		get-flag-value var -- --var=value
		^ outputs: value

		get-flag-value var -- --var=
		^ outputs an empty line

		get-flag-value var --yes=yup --no=nada --missing=gone -- --var
		^ outputs: yup

		get-flag-value var --yes=yup --no=nada --missing=gone -- --var=yes
		^ outputs: yes

		get-flag-value var --yes=yup --no=nada --missing=gone -- --no-var
		^ outputs: nada

		get-flag-value var --yes=yup --no=nada --missing=gone -- --var=no
		^ outputs: no

		get-flag-value var --yes=yup --no=nada --missing=gone --
		^ outputs: gone
	EOF
	exit 22 # Invalid argument
fi

function get_flag_value {
	local name yes no missing multi item found inverted index value

	# handle our own options
	name=''
	yes='yes'
	no='no'
	missing=''
	multi='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--yes='*) yes="${item:6}" ;;
		'--no='*) no="${item:5}" ;;
		'--missing='*) missing="${item:10}" ;;
		'--multi') multi="yes" ;;
		'--') break ;;
		'--'*)
			echo-style --error="unrecognised flag: $item" >/dev/stderr
			return 22 # Invalid argument
			;;
		*)
			if test -z "$name"; then
				name="$item"
			else
				echo-style --error="unrecognised argument: $item" >/dev/stderr
				return 22 # Invalid argument
			fi
			;;
		esac
	done

	# cycle through args
	found='no'
	for item in "$@"; do
		# prepare
		inverted='no'
		index=0

		# check flag status
		if test "${item:0:2}" != '--'; then
			# not a flag
			continue
		fi
		index=2

		# check inversion
		if test "${item:index:3}" == 'no-'; then
			# is inverted
			inverted='yes'
			index=5
		fi

		# check is our flag
		if test "${item:index:${#name}}" != "$name"; then
			# not our flag
			continue
		fi
		found='yes'

		# get the value
		value="${item:index+${#name}}"
		if test -z "$value"; then
			value="$yes"
		elif test "${value:0:1}" = '='; then
			# is a proper value, trim =
			value="${value:1}"
		fi

		# perform inversion
		if test "$inverted" = 'yes'; then
			if test "$value" = "$yes"; then
				value="$no"
			elif test "$value" = "$no"; then
				value="$yes"
			fi
		fi

		# echo
		echo "$value"

		# if single, one result is all we want
		if test "$multi" = 'no'; then
			break
		fi
	done

	# handle missing case
	if test "$found" = 'no' -a -n "$missing"; then
		echo "$missing"
	fi
}

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	get_flag_value "$@"
fi

#!/usr/bin/env bash
source "$DOTFILES/sources/strict.bash"

# =====================================
# Arguments

# help
function help() {
	cat <<-EOF >/dev/stderr
		ABOUT:
		Mounts a source (be it a drive or gocryptfs vault) to a mount point.

		USAGE:
		fs-mount [--] <source> <mount-point> [<owner>]
		fs-mount [--] [--source=<source>] [--target=<mount-point>] [--owner=<owner>] [--user=<user>] [--group=<group>]

		QUIRKS:
		If [owner/user/group] is provided, then the mount point will be enforced to that owner/user/group.
	EOF
	if test "$#" -ne 0; then
		echo-style $'\n' --error="ERROR:" $'\n' --red="$(echo-lines -- "$@")" >/dev/stderr
	fi
	return 22 # Invalid argument
}

# prepare
while test "${1-}" = '--'; do
	shift
done

# process
paths=()
mount_source=''
mount_target=''
option_owner=''
option_user=''
option_group=''
while test "$#" -ne 0; do
	item="$1"
	shift
	case "$item" in
	'help' | '--help' | '-h') help ;;
	'--source='*) mount_source="${item:9}" ;;
	'--target='*) mount_target="${item:9}" ;;
	'--owner='*) option_owner="${item:8}" ;;
	'--user='*) option_user="${item:7}" ;;
	'--group='*) option_group="${item:8}" ;;
	'--')
		paths+=("$@")
		shift $#
		break
		;;
	'--'*) help "An unrecognised flag was provided: $item" ;;
	*)
		if test -z "$mount_source"; then
			mount_source="$item"
		elif test -z "$mount_target"; then
			mount_target="$item"
		elif test -z "$option_owner"; then
			option_owner="$item"
		else
			help "An unrecognised argument was provided: $item"
		fi
		;;
	esac
done

# check
if test -z "$mount_source" -o -z "$mount_target"; then
	help "No paths were provided."
fi

# =====================================
# Helpers

function is_drive {
	[[ "$1" = '/dev/'* ]]
}

# =====================================
# Act

title="fs-mount ${mount_source@Q}"
conclusion=''
mount_cmd=()

function fs_mount() {
	local chown='no'

	# verify and prep
	if is_drive "$mount_source"; then
		# mount drive
		mount_cmd+=(
			'sudo'
			'mount'
			"$mount_source"
			"$mount_target"
		)
		# instruct to chown
		chown='yes'
	elif gocryptfs-helper verify -- "$mount_source" &>/dev/null; then
		# mount vault
		mount_cmd+=(
			'gocryptfs-helper'
			'mount'
			'--'
			"$mount_source"
			"$mount_target"
			"--owner=$option_owner"
			"--user=$option_user"
			"--group=$option_group"
		)
	else
		conclusion="$(
			echo-style --red="invalid mount source."
		)"
		echo-style --error="fs-mount doesn't know how to mount ${mount_source@Q}, it is neither a drive nor a gocryptfs vault"
		return 22 # Invalid argument
	fi

	# if already mounted, then only do perms
	if test -d "$mount_target"; then
		if is-mounted --source="$mount_source" --target="$mount_target"; then
			echo-style --bold="${mount_source@Q}" " already mounted to " --bold="${mount_target@Q}"
			if ! confirm-bool --ppid=$$ -- 'Do you wish to remount?'; then
				conclusion="$(
					echo-style --green="was previously mounted."
				)"
				return "$?"
			fi
		fi

		# if mount is invalid, then unmount the directory
		fs-unmount -- "$mount_target"
	fi

	# if not mounted, go through the process
	sudo mkdir -p "$mount_target"
	fs-own --owner="$option_owner" --user="$option_user" --group="$option_group" -- "$mount_target"

	# mount
	echo-eval -- "${mount_cmd[@]}"
	echo-style --success="${mount_source@Q} was mounted."
	if test "$chown" = 'yes'; then
		fs-own --owner="$option_owner" --user="$option_user" --group="$option_group" -- "$mount_target"
	fi

	# success
	conclusion="$(
		echo-style --green="mounted successfully."
	)"
}

# act
echo-segment --h2="$title"
if fs_mount; then
	echo-segment --g2="$title" " $conclusion"
else
	echo-segment --e2="$title" " $conclusion"
fi
